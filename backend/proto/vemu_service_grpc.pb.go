// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.26.1
// source: vemu_service.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	VemuService_Reset_FullMethodName           = "/vemu.v1.VemuService/Reset"
	VemuService_Shutdown_FullMethodName        = "/vemu.v1.VemuService/Shutdown"
	VemuService_LoadFirmware_FullMethodName    = "/vemu.v1.VemuService/LoadFirmware"
	VemuService_LoadBinaryBlob_FullMethodName  = "/vemu.v1.VemuService/LoadBinaryBlob"
	VemuService_Step_FullMethodName            = "/vemu.v1.VemuService/Step"
	VemuService_Run_FullMethodName             = "/vemu.v1.VemuService/Run"
	VemuService_Pause_FullMethodName           = "/vemu.v1.VemuService/Pause"
	VemuService_QueryState_FullMethodName      = "/vemu.v1.VemuService/QueryState"
	VemuService_ReadMemory_FullMethodName      = "/vemu.v1.VemuService/ReadMemory"
	VemuService_WriteMemory_FullMethodName     = "/vemu.v1.VemuService/WriteMemory"
	VemuService_ReadVector_FullMethodName      = "/vemu.v1.VemuService/ReadVector"
	VemuService_WriteVector_FullMethodName     = "/vemu.v1.VemuService/WriteVector"
	VemuService_GetRegs_FullMethodName         = "/vemu.v1.VemuService/GetRegs"
	VemuService_SetReg_FullMethodName          = "/vemu.v1.VemuService/SetReg"
	VemuService_GetCSR_FullMethodName          = "/vemu.v1.VemuService/GetCSR"
	VemuService_SetCSR_FullMethodName          = "/vemu.v1.VemuService/SetCSR"
	VemuService_TraceStream_FullMethodName     = "/vemu.v1.VemuService/TraceStream"
	VemuService_SetBreakpoint_FullMethodName   = "/vemu.v1.VemuService/SetBreakpoint"
	VemuService_ClearBreakpoint_FullMethodName = "/vemu.v1.VemuService/ClearBreakpoint"
)

// VemuServiceClient is the client API for VemuService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// VemuService defines the gRPC interface for interacting with the RISC-V emulator.
// It provides methods for controlling the simulation, managing state, and interacting with memory and registers.
// 仿真器 gRPC 服务接口，提供仿真控制、状态管理、内存和寄存器交互等功能。
//
// ────────────────── ① 生命周期 ──────────────────
type VemuServiceClient interface {
	// Resets the emulator to its initial state.
	// 重置仿真器到初始状态。
	Reset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error)
	// Shuts down the emulator instance gracefully.
	// 安全地关闭仿真器实例。
	Shutdown(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error)
	// ──────────────── ② 装载固件 / 数据 ────────────────
	// Loads a program into the emulator's memory from a hex file format.
	// 从 hex 文件格式加载程序到仿真器内存。
	LoadFirmware(ctx context.Context, in *LoadFirmwareRequest, opts ...grpc.CallOption) (*Status, error)
	// (Not yet implemented) Loads a raw binary blob into a specific memory address.
	// (尚未实现) 加载二进制数据到指定内存地址。
	LoadBinaryBlob(ctx context.Context, in *LoadBinaryRequest, opts ...grpc.CallOption) (*Status, error)
	// ──────────────── ③ 运行控制 ────────────────
	// Executes a single instruction or a small number of cycles.
	// 执行单条指令或少量周期。
	Step(ctx context.Context, in *StepRequest, opts ...grpc.CallOption) (*StepResponse, error)
	// Runs the simulation continuously until a breakpoint is hit, an error occurs, or it is paused.
	// 连续运行仿真，直到遇到断点、错误或暂停。
	Run(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (*RunResponse, error)
	// Pauses a running simulation.
	// 暂停正在运行的仿真。
	Pause(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error)
	// Queries the current complete state of the CPU, including registers and cycle count.
	// 查询当前完整的 CPU 状态，包括寄存器和周期计数。
	QueryState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CpuState, error)
	// ──────────────── ④ 存储访问 ────────────────
	// Reads a block of memory from a specified address.
	// 从指定地址读取一块内存。
	ReadMemory(ctx context.Context, in *ReadMemRequest, opts ...grpc.CallOption) (*ReadMemResponse, error)
	// Writes a block of data to a specified memory address.
	// 向指定内存地址写入一块数据。
	WriteMemory(ctx context.Context, in *WriteMemRequest, opts ...grpc.CallOption) (*Status, error)
	// Reads a row from the Venus DSPM (vector scratchpad memory).
	// 专门读取/写入 Venus DSPM (向量暂存器)。
	ReadVector(ctx context.Context, in *ReadVectorRequest, opts ...grpc.CallOption) (*ReadVectorResponse, error)
	// Writes a row to the Venus DSPM.
	// 向 Venus DSPM 写入一行数据。
	WriteVector(ctx context.Context, in *WriteVectorRequest, opts ...grpc.CallOption) (*Status, error)
	// ──────────────── ⑤ CPU/CSR 访问 ────────────────
	// (Not yet implemented) Gets the entire general-purpose register file.
	// (尚未实现) 获取所有通用寄存器。
	GetRegs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RegisterFile, error)
	// Sets the value of a single general-purpose register.
	// 设置单个通用寄存器的值。
	SetReg(ctx context.Context, in *SetRegRequest, opts ...grpc.CallOption) (*Status, error)
	// Gets the value of a Control and Status Register (CSR).
	// 获取一个控制和状态寄存器 (CSR) 的值。
	GetCSR(ctx context.Context, in *GetCsrRequest, opts ...grpc.CallOption) (*GetCsrResponse, error)
	// Sets the value of a Control and Status Register (CSR).
	// 设置一个控制和状态寄存器 (CSR) 的值。
	SetCSR(ctx context.Context, in *SetCsrRequest, opts ...grpc.CallOption) (*Status, error)
	// ──────────────── ⑥ 调试 / 事件流 ────────────────
	// Streams execution trace events from the server to the client.
	// 以流的形式将执行跟踪事件从服务端发送到客户端。
	TraceStream(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TraceEvent], error)
	// Sets a breakpoint at a specific program counter (PC) address.
	// 在指定的程序计数器 (PC) 地址设置断点。
	SetBreakpoint(ctx context.Context, in *BreakpointRequest, opts ...grpc.CallOption) (*Status, error)
	// Clears a previously set breakpoint.
	// 清除一个已设置的断点。
	ClearBreakpoint(ctx context.Context, in *BreakpointRequest, opts ...grpc.CallOption) (*Status, error)
}

type vemuServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVemuServiceClient(cc grpc.ClientConnInterface) VemuServiceClient {
	return &vemuServiceClient{cc}
}

func (c *vemuServiceClient) Reset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, VemuService_Reset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) Shutdown(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, VemuService_Shutdown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) LoadFirmware(ctx context.Context, in *LoadFirmwareRequest, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, VemuService_LoadFirmware_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) LoadBinaryBlob(ctx context.Context, in *LoadBinaryRequest, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, VemuService_LoadBinaryBlob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) Step(ctx context.Context, in *StepRequest, opts ...grpc.CallOption) (*StepResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StepResponse)
	err := c.cc.Invoke(ctx, VemuService_Step_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) Run(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (*RunResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunResponse)
	err := c.cc.Invoke(ctx, VemuService_Run_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) Pause(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, VemuService_Pause_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) QueryState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CpuState, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CpuState)
	err := c.cc.Invoke(ctx, VemuService_QueryState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) ReadMemory(ctx context.Context, in *ReadMemRequest, opts ...grpc.CallOption) (*ReadMemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadMemResponse)
	err := c.cc.Invoke(ctx, VemuService_ReadMemory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) WriteMemory(ctx context.Context, in *WriteMemRequest, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, VemuService_WriteMemory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) ReadVector(ctx context.Context, in *ReadVectorRequest, opts ...grpc.CallOption) (*ReadVectorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadVectorResponse)
	err := c.cc.Invoke(ctx, VemuService_ReadVector_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) WriteVector(ctx context.Context, in *WriteVectorRequest, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, VemuService_WriteVector_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) GetRegs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RegisterFile, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterFile)
	err := c.cc.Invoke(ctx, VemuService_GetRegs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) SetReg(ctx context.Context, in *SetRegRequest, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, VemuService_SetReg_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) GetCSR(ctx context.Context, in *GetCsrRequest, opts ...grpc.CallOption) (*GetCsrResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCsrResponse)
	err := c.cc.Invoke(ctx, VemuService_GetCSR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) SetCSR(ctx context.Context, in *SetCsrRequest, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, VemuService_SetCSR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) TraceStream(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TraceEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &VemuService_ServiceDesc.Streams[0], VemuService_TraceStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Empty, TraceEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VemuService_TraceStreamClient = grpc.ServerStreamingClient[TraceEvent]

func (c *vemuServiceClient) SetBreakpoint(ctx context.Context, in *BreakpointRequest, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, VemuService_SetBreakpoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vemuServiceClient) ClearBreakpoint(ctx context.Context, in *BreakpointRequest, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, VemuService_ClearBreakpoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VemuServiceServer is the server API for VemuService service.
// All implementations must embed UnimplementedVemuServiceServer
// for forward compatibility.
//
// VemuService defines the gRPC interface for interacting with the RISC-V emulator.
// It provides methods for controlling the simulation, managing state, and interacting with memory and registers.
// 仿真器 gRPC 服务接口，提供仿真控制、状态管理、内存和寄存器交互等功能。
//
// ────────────────── ① 生命周期 ──────────────────
type VemuServiceServer interface {
	// Resets the emulator to its initial state.
	// 重置仿真器到初始状态。
	Reset(context.Context, *Empty) (*Status, error)
	// Shuts down the emulator instance gracefully.
	// 安全地关闭仿真器实例。
	Shutdown(context.Context, *Empty) (*Status, error)
	// ──────────────── ② 装载固件 / 数据 ────────────────
	// Loads a program into the emulator's memory from a hex file format.
	// 从 hex 文件格式加载程序到仿真器内存。
	LoadFirmware(context.Context, *LoadFirmwareRequest) (*Status, error)
	// (Not yet implemented) Loads a raw binary blob into a specific memory address.
	// (尚未实现) 加载二进制数据到指定内存地址。
	LoadBinaryBlob(context.Context, *LoadBinaryRequest) (*Status, error)
	// ──────────────── ③ 运行控制 ────────────────
	// Executes a single instruction or a small number of cycles.
	// 执行单条指令或少量周期。
	Step(context.Context, *StepRequest) (*StepResponse, error)
	// Runs the simulation continuously until a breakpoint is hit, an error occurs, or it is paused.
	// 连续运行仿真，直到遇到断点、错误或暂停。
	Run(context.Context, *RunRequest) (*RunResponse, error)
	// Pauses a running simulation.
	// 暂停正在运行的仿真。
	Pause(context.Context, *Empty) (*Status, error)
	// Queries the current complete state of the CPU, including registers and cycle count.
	// 查询当前完整的 CPU 状态，包括寄存器和周期计数。
	QueryState(context.Context, *Empty) (*CpuState, error)
	// ──────────────── ④ 存储访问 ────────────────
	// Reads a block of memory from a specified address.
	// 从指定地址读取一块内存。
	ReadMemory(context.Context, *ReadMemRequest) (*ReadMemResponse, error)
	// Writes a block of data to a specified memory address.
	// 向指定内存地址写入一块数据。
	WriteMemory(context.Context, *WriteMemRequest) (*Status, error)
	// Reads a row from the Venus DSPM (vector scratchpad memory).
	// 专门读取/写入 Venus DSPM (向量暂存器)。
	ReadVector(context.Context, *ReadVectorRequest) (*ReadVectorResponse, error)
	// Writes a row to the Venus DSPM.
	// 向 Venus DSPM 写入一行数据。
	WriteVector(context.Context, *WriteVectorRequest) (*Status, error)
	// ──────────────── ⑤ CPU/CSR 访问 ────────────────
	// (Not yet implemented) Gets the entire general-purpose register file.
	// (尚未实现) 获取所有通用寄存器。
	GetRegs(context.Context, *Empty) (*RegisterFile, error)
	// Sets the value of a single general-purpose register.
	// 设置单个通用寄存器的值。
	SetReg(context.Context, *SetRegRequest) (*Status, error)
	// Gets the value of a Control and Status Register (CSR).
	// 获取一个控制和状态寄存器 (CSR) 的值。
	GetCSR(context.Context, *GetCsrRequest) (*GetCsrResponse, error)
	// Sets the value of a Control and Status Register (CSR).
	// 设置一个控制和状态寄存器 (CSR) 的值。
	SetCSR(context.Context, *SetCsrRequest) (*Status, error)
	// ──────────────── ⑥ 调试 / 事件流 ────────────────
	// Streams execution trace events from the server to the client.
	// 以流的形式将执行跟踪事件从服务端发送到客户端。
	TraceStream(*Empty, grpc.ServerStreamingServer[TraceEvent]) error
	// Sets a breakpoint at a specific program counter (PC) address.
	// 在指定的程序计数器 (PC) 地址设置断点。
	SetBreakpoint(context.Context, *BreakpointRequest) (*Status, error)
	// Clears a previously set breakpoint.
	// 清除一个已设置的断点。
	ClearBreakpoint(context.Context, *BreakpointRequest) (*Status, error)
	mustEmbedUnimplementedVemuServiceServer()
}

// UnimplementedVemuServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVemuServiceServer struct{}

func (UnimplementedVemuServiceServer) Reset(context.Context, *Empty) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reset not implemented")
}
func (UnimplementedVemuServiceServer) Shutdown(context.Context, *Empty) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Shutdown not implemented")
}
func (UnimplementedVemuServiceServer) LoadFirmware(context.Context, *LoadFirmwareRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadFirmware not implemented")
}
func (UnimplementedVemuServiceServer) LoadBinaryBlob(context.Context, *LoadBinaryRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadBinaryBlob not implemented")
}
func (UnimplementedVemuServiceServer) Step(context.Context, *StepRequest) (*StepResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Step not implemented")
}
func (UnimplementedVemuServiceServer) Run(context.Context, *RunRequest) (*RunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Run not implemented")
}
func (UnimplementedVemuServiceServer) Pause(context.Context, *Empty) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pause not implemented")
}
func (UnimplementedVemuServiceServer) QueryState(context.Context, *Empty) (*CpuState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryState not implemented")
}
func (UnimplementedVemuServiceServer) ReadMemory(context.Context, *ReadMemRequest) (*ReadMemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadMemory not implemented")
}
func (UnimplementedVemuServiceServer) WriteMemory(context.Context, *WriteMemRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteMemory not implemented")
}
func (UnimplementedVemuServiceServer) ReadVector(context.Context, *ReadVectorRequest) (*ReadVectorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadVector not implemented")
}
func (UnimplementedVemuServiceServer) WriteVector(context.Context, *WriteVectorRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteVector not implemented")
}
func (UnimplementedVemuServiceServer) GetRegs(context.Context, *Empty) (*RegisterFile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegs not implemented")
}
func (UnimplementedVemuServiceServer) SetReg(context.Context, *SetRegRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetReg not implemented")
}
func (UnimplementedVemuServiceServer) GetCSR(context.Context, *GetCsrRequest) (*GetCsrResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCSR not implemented")
}
func (UnimplementedVemuServiceServer) SetCSR(context.Context, *SetCsrRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCSR not implemented")
}
func (UnimplementedVemuServiceServer) TraceStream(*Empty, grpc.ServerStreamingServer[TraceEvent]) error {
	return status.Errorf(codes.Unimplemented, "method TraceStream not implemented")
}
func (UnimplementedVemuServiceServer) SetBreakpoint(context.Context, *BreakpointRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetBreakpoint not implemented")
}
func (UnimplementedVemuServiceServer) ClearBreakpoint(context.Context, *BreakpointRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearBreakpoint not implemented")
}
func (UnimplementedVemuServiceServer) mustEmbedUnimplementedVemuServiceServer() {}
func (UnimplementedVemuServiceServer) testEmbeddedByValue()                     {}

// UnsafeVemuServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VemuServiceServer will
// result in compilation errors.
type UnsafeVemuServiceServer interface {
	mustEmbedUnimplementedVemuServiceServer()
}

func RegisterVemuServiceServer(s grpc.ServiceRegistrar, srv VemuServiceServer) {
	// If the following call pancis, it indicates UnimplementedVemuServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VemuService_ServiceDesc, srv)
}

func _VemuService_Reset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).Reset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_Reset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).Reset(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_Shutdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).Shutdown(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_LoadFirmware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadFirmwareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).LoadFirmware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_LoadFirmware_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).LoadFirmware(ctx, req.(*LoadFirmwareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_LoadBinaryBlob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadBinaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).LoadBinaryBlob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_LoadBinaryBlob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).LoadBinaryBlob(ctx, req.(*LoadBinaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_Step_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).Step(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_Step_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).Step(ctx, req.(*StepRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_Run_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).Run(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_Run_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).Run(ctx, req.(*RunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_Pause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).Pause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_Pause_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).Pause(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_QueryState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).QueryState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_QueryState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).QueryState(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_ReadMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadMemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).ReadMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_ReadMemory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).ReadMemory(ctx, req.(*ReadMemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_WriteMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteMemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).WriteMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_WriteMemory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).WriteMemory(ctx, req.(*WriteMemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_ReadVector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadVectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).ReadVector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_ReadVector_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).ReadVector(ctx, req.(*ReadVectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_WriteVector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteVectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).WriteVector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_WriteVector_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).WriteVector(ctx, req.(*WriteVectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_GetRegs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).GetRegs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_GetRegs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).GetRegs(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_SetReg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRegRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).SetReg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_SetReg_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).SetReg(ctx, req.(*SetRegRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_GetCSR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCsrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).GetCSR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_GetCSR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).GetCSR(ctx, req.(*GetCsrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_SetCSR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCsrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).SetCSR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_SetCSR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).SetCSR(ctx, req.(*SetCsrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_TraceStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VemuServiceServer).TraceStream(m, &grpc.GenericServerStream[Empty, TraceEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VemuService_TraceStreamServer = grpc.ServerStreamingServer[TraceEvent]

func _VemuService_SetBreakpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreakpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).SetBreakpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_SetBreakpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).SetBreakpoint(ctx, req.(*BreakpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VemuService_ClearBreakpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreakpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VemuServiceServer).ClearBreakpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VemuService_ClearBreakpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VemuServiceServer).ClearBreakpoint(ctx, req.(*BreakpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VemuService_ServiceDesc is the grpc.ServiceDesc for VemuService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VemuService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vemu.v1.VemuService",
	HandlerType: (*VemuServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Reset",
			Handler:    _VemuService_Reset_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _VemuService_Shutdown_Handler,
		},
		{
			MethodName: "LoadFirmware",
			Handler:    _VemuService_LoadFirmware_Handler,
		},
		{
			MethodName: "LoadBinaryBlob",
			Handler:    _VemuService_LoadBinaryBlob_Handler,
		},
		{
			MethodName: "Step",
			Handler:    _VemuService_Step_Handler,
		},
		{
			MethodName: "Run",
			Handler:    _VemuService_Run_Handler,
		},
		{
			MethodName: "Pause",
			Handler:    _VemuService_Pause_Handler,
		},
		{
			MethodName: "QueryState",
			Handler:    _VemuService_QueryState_Handler,
		},
		{
			MethodName: "ReadMemory",
			Handler:    _VemuService_ReadMemory_Handler,
		},
		{
			MethodName: "WriteMemory",
			Handler:    _VemuService_WriteMemory_Handler,
		},
		{
			MethodName: "ReadVector",
			Handler:    _VemuService_ReadVector_Handler,
		},
		{
			MethodName: "WriteVector",
			Handler:    _VemuService_WriteVector_Handler,
		},
		{
			MethodName: "GetRegs",
			Handler:    _VemuService_GetRegs_Handler,
		},
		{
			MethodName: "SetReg",
			Handler:    _VemuService_SetReg_Handler,
		},
		{
			MethodName: "GetCSR",
			Handler:    _VemuService_GetCSR_Handler,
		},
		{
			MethodName: "SetCSR",
			Handler:    _VemuService_SetCSR_Handler,
		},
		{
			MethodName: "SetBreakpoint",
			Handler:    _VemuService_SetBreakpoint_Handler,
		},
		{
			MethodName: "ClearBreakpoint",
			Handler:    _VemuService_ClearBreakpoint_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TraceStream",
			Handler:       _VemuService_TraceStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "vemu_service.proto",
}
